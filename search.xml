<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【译】Promise/A+规范</title>
      <link href="/2019/12/03/translate-promise-a-specifications/"/>
      <url>/2019/12/03/translate-promise-a-specifications/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>原文：<a href="https://promisesaplus.com" target="_blank" rel="noopener">https://promisesaplus.com</a></p></blockquote><h1 class="promisesa">Promises/A+</h1><p><strong>Promises/A+是一个开放标准，一个规定了如何互相嵌套使用 JavaScript promises 的开放标准—由实现者制定和使用。</strong></p><p>一个 <em>promise</em> 代表异步操作的最终结果。与 promise 交互的主要方法是使用它的 <code>then</code> 方法，该方法注册回调函数来接收 promise 最终的 value 或者 promise 不能正常完成（fulfill）的 reason。</p><p>本规范详细描述了 <code>then</code> 方法的行为，给所有遵循 Promises/A+ 规范实现的 promise 提供一份实现基础。所以，可以认为本规范是非常稳定的。尽管 promise/A+ 组织可能偶尔会对这个规范做向后兼容的小修改以解决新发现的边界问题，只有在仔细考虑、讨论和测试之后，我们才会集成大型的或向后不兼容的变更。</p><p>从历史上看，Promises/A+ 澄清了早期 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">Promises/A</a> 提议的行为条款，扩展它以覆盖 <em>事实</em> 行为，并删除未指定或有问题的部分。</p><p>最后，Promises/A+ 规范的核心不会去演示如何创建、完成（fulfill）或者拒绝（reject）promises 对象，选择将重点放在提供一个互相嵌套的then方法上。未来在相关规范的工作中可能会涉及这些主题。</p><h1 id="1-术语"><a href="#1-术语" class="headerlink" title="1.术语"></a>1.术语</h1><ul><li>1.1. “promise” 是一个具有 <code>then</code> 方法的对象或函数，该 <code>then</code> 方法的行为符合这个规范。</li><li>1.2. “thenable” 是一个定义了 <code>then</code> 方法的对象或函数。</li><li>1.3. “value” 是任何合法的 JavaScript 值（包括 <code>undefined</code>、thenable 或 promise）。</li><li>1.4. “exception” 是使用 <code>throw</code> 语句抛出的一个值。</li><li>1.5. “reason” 是一个值，它指示了一个 promise 为什么被拒绝（rejected）。</li></ul><h1 id="2-要求"><a href="#2-要求" class="headerlink" title="2.要求"></a>2.要求</h1><h2 id="2-1-promise-的状态"><a href="#2-1-promise-的状态" class="headerlink" title="2.1. promise 的状态"></a>2.1. promise 的状态</h2><p>promise 必须是三种状态之一：pending（等待态）、fulfilled（完成态）或 rejected（拒绝态）。</p><p>2.1.1. 处于 pending，promise：</p><ul><li>2.1.1.1. 可以过渡到 fulfilled 或 或rejected 状态。</li></ul><p>2.1.2. 处于 fulfilled，promise：</p><ul><li>2.1.2.1. 一定不能过渡到任何其他状态。</li><li>2.1.2.2. 必须有一个不变的 value。</li></ul><p>2.1.3. 处于 rejected，promise：</p><ul><li>2.1.3.1. 一定不能过渡到任何其他状态。</li><li>2.1.3.2. 必须有一个不变的 reason。</li></ul><p>这里说的 “不变” 是指，不变的引用（即 <code>===</code>），但并不意味着深度不变。</p><h2 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2. then 方法"></a>2.2. <code>then</code> 方法</h2><p>一个 promise 必须提供一个 <code>then</code> 方法来访问它当前或最终的 value 或 reason。<br>一个 promise 的 <code>then</code> 方法接受两个参数：</p><pre class="line-numbers language-js"><code class="language-js">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.2.1. <code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数：</p><ul><li>2.2.1.1. 如果 <code>onFulfilled</code> 不是一个函数，它必须被忽略。</li><li>2.2.1.2. 如果 <code>onRejected</code> 不是一个函数，它必须被忽略。</li></ul><p>2.2.2. 如果 <code>onFulfilled</code> 是一个函数：</p><ul><li>2.2.2.1. 它必须在 <code>promise</code> fulfilled 后被调用，<code>promise</code> 的 value 是它的第一个参数。</li><li>2.2.2.2. 它一定不能在 <code>promise</code> fulfilled 之后调用。</li><li>2.2.2.3. 它不能被调用超过一次。</li></ul><p>2.2.3. 如果 <code>onRejected</code> 是一个函数：</p><ul><li>2.2.3.1. 它必须在 <code>promise</code> rejected 后被调用，<code>promise</code> 的 reason 是它的第一个参数。</li><li>2.2.3.2. 它一定不能在 <code>promise</code> rejected 之后调用。</li><li>2.2.3.3. 它不能被调用超过一次。</li></ul><p>2.2.4. <code>onFulfilled</code> 或 <code>onRejected</code> 只有在 <a href="https://es5.github.io/#x10.3" target="_blank" rel="noopener">执行上下文</a> 堆栈仅包含平台代码时才可被调用<a id="ref-3-1" href="#3-1" rel="footnote"><sup>[3.1]</sup></a>。</p><p>2.2.5. <code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）。<a id="ref-3-2" href="#3-2" rel="footnote"><sup>[3.2]</sup></a></p><p>2.2.6. <code>then</code> 方法可以被同一个 promise 对象调用多次。</p><ul><li>2.2.6.1. 如果/当 <code>promise</code> 执行完成后，所有相应的 <code>onFulfilled</code> 回调函数，必须按照对 <code>then</code> 的原始调用的顺序执行。</li><li>2.2.6.2. 如果/当 <code>promise</code> 执行被拒绝后，所有相应的 <code>onRejected</code> 回调函数，必须按照对 <code>then</code> 的原始调用的顺序执行。</li></ul><p>2.2.7. <code>then</code> 必须返回一个 promise 对象 <a id="ref-3-3" href="#3-3" rel="footnote"><sup>[3.3]</sup></a></p><pre class="line-numbers language-js"><code class="language-js">promise2 <span class="token operator">=</span> promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>2.2.7.1. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 中任何一个返回一个值 <code>x</code> ，运行 Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>。</li><li>2.2.7.2. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code>，<code>promise2</code> 必须以 <code>e</code> 作为被拒绝执行的原因。</li><li>2.2.7.3. 如果 <code>onFulfilled</code> 不是函数，并且 <code>promise1</code> 执行完成，<code>promise2</code> 必须用和 <code>promise1</code> 相同的 value 达到完成态。</li><li>2.2.7.4. 如果 <code>onRejected</code> 不是函数，并且 <code>promise1</code> 执行被拒绝，<code>promise2</code> 必须用和 <code>promise1</code> 相同的 reason 达到拒绝态。</li></ul><h2 id="2-3-Promise-Resolution-Procedure（PRP）"><a href="#2-3-Promise-Resolution-Procedure（PRP）" class="headerlink" title="2.3. Promise Resolution Procedure（PRP）"></a>2.3. Promise Resolution Procedure（PRP）</h2><p><strong>Promise Resolution Procedure（promise 解决过程）</strong> 是一个以 promise 和一个值作为输入参数的抽象操作，<br>我们将其表示为 <code>[[Resolve]](promise, x)</code>。如果 <code>x</code> 是一个 thenable 的对象（即一个拥有 then 方法的函数或对象），假设 <code>x</code> 的行为至少有点像 <code>promise</code>，那么 PRP 试图使 <code>promise</code> 采用 <code>x</code> 的状态；否则用 <code>x</code> 的值来完成 <code>promise</code>。</p><p>这种对 thenable 的处理允许 promise 实现相互操作，只要他们公开一个 Promises/A+ 兼容的 <code>then</code> 方法即可。它也允许对那些不符合 Promises/A+ 的 <code>then</code> 方法进行”吸收”。</p><p>要运行 <code>[[Resolve]](promise, x)</code>，需通过以下步骤：</p><ul><li>2.3.1. 如果 <code>promise</code> 和 <code>x</code> 引用同一对象<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="即循环引用。">[1]</span></a></sup>，以 <code>TypeError</code> 为原因拒绝 promise。</li><li>2.3.2. 如果 <code>x</code> 是一个 promise 对象，则 采用 <code>x</code> 的状态 <a id="ref-3-4" href="#3-4" rel="footnote"><sup>[3.4]</sup></a>。<ul><li>2.3.2.1. 如果 <code>x</code> 处于 pending，<code>promise</code> 必须保持 pending 直到 <code>x</code> 变成 fulfilled 或 rejected。</li><li>2.3.2.2. 如果/当 <code>x</code> 处于 fulfilled，使用相同的 value 完成 <code>promise</code>。</li><li>2.3.2.3. 如果/当 <code>x</code> 处于 rejected，使用相同的 reason 拒绝 <code>promise</code>。</li></ul></li><li>2.3.3. 此外，如果 <code>x</code> 是一个对象或函数：<ul><li>2.3.3.1. 把 <code>x.then</code> 赋值给 <code>then</code>。<a id="ref-3-5" href="#3-5" rel="footnote"><sup>[3.5]</sup></a></li><li>2.3.3.2. 如果取属性 <code>x.then</code> 的值时意外抛出错误 <code>e</code>，则使用 <code>e</code> 作为原因拒绝 <code>promise</code>。</li><li>2.3.3.3. 如果 <code>then</code> 是一个函数，则以 <code>x</code> 作为 <code>this</code> 对其调用，以 <code>resolvePromise</code> 作为第一个参数，<code>rejectPromise</code> 作为第二个参数，其中:<ul><li>2.3.3.3.1. 如果/当以值 <code>y</code> 为参数调用 <code>resolvePromise</code> 时，则运行 <code>[[Resolve]](promise, y)</code>。</li><li>2.3.3.3.2. 如果/当以原因 <code>r</code> 为参数调用 <code>rejectPromise</code> 时，则使用 <code>r</code> 拒绝 <code>promise</code>。</li><li>2.3.3.3.3. 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用，或者被使用相同的参数调用了多次，则首次调用将被优先采用，任何其它调用将被忽略。</li><li>2.3.3.3.4. 如果调用 <code>then</code> 抛出异常 <code>e</code>：<ul><li>2.3.3.3.4.1. 如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略该异常。</li><li>2.3.3.3.4.2. 否则，使用 <code>e</code> 为原因拒绝 <code>promise</code>。</li></ul></li></ul></li><li>2.3.3.4. 如果 <code>then</code> 不是函数，以 <code>x</code> 为值完成 <code>promise</code>。</li></ul></li><li>2.3.4 如果 <code>x</code> 不是对象或者函数，以 <code>x</code> 为值完成 <code>promise</code>。</li></ul><p>如果使用参与循环 thenable 链的 thenable 来 resolve promise<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="即调用时类似[[Resolve]](promise, promise)，这样的话这两个实参是同一个 promise 对象，则会导致无限递归。">[2]</span></a></sup>，由于 <code>[[Resolve]](promise, thenable)</code> 的递归性质最终导致再次调用 <code>[[Resolve]](promise, thenable)</code>，按照上面的算法将会导致无限递归。本规范鼓励但不要求实现检测这种递归，并以 <code>TypeError</code> 作为原因拒绝 <code>promise</code><a id="ref-3-6" href="#3-6" rel="footnote"><sup>[3.6]</sup></a>。</p><h1 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h1><p id="3-1">    <span style="float: left;">3.1. </span>    </p><p style="margin-left: 32px;">        这里“平台代码”是指引擎、环境以及 promise 的实现代码。        实际上，这个要求确保了 <code>onFulfilled</code> 和 <code>onRejected</code> 异步执行，        即在调用 <code>then</code> 方法的那个事件循环之后的新执行栈中执行。        这个可以通过"宏任务（macro-task）"机制如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="noopener"><code>setTimeout</code></a> 或者 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="noopener"><code>setImmediate</code></a>        或者"微任务（micro-task）"机制如 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="noopener"><code>MutationObserver</code></a> 或者 <a href="https://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener"><code>process.nextTick</code></a> 来实现。        因为 promise 的实现被当作是平台代码，        所以它本身可能会包含一个任务调度队列或者 "trampoline" 来调用处理程序。        <a href="#ref-3-1" rev="footnote"> ↩</a>    </p><p></p><p id="3-2">    <span style="float: left;">3.2. </span>    </p><p style="margin-left: 32px;">        也就是说，<code>this</code> 的值，在严格模式下为 <code>undefined</code>；        在宽松模式下为 global 对象。        <a href="#ref-3-2" rev="footnote"> ↩</a>    </p><p></p><p id="3-3">    <span style="float: left;">3.3. </span>    </p><p style="margin-left: 32px;">        实现可能允许 <code>promise2 === promise1</code>，前提是实现满足所有需求。每个实现都应该记录它是否能够生成 <code>promise2 === promise1</code>，以及在什么条件下生成。        <a href="#ref-3-3" rev="footnote"> ↩</a>    </p><p></p><p id="3-4">    <span style="float: left;">3.4. </span>    </p><p style="margin-left: 32px;">        通常，只有当 <code>x</code> 来自当前实现，我们才知道它是一个真正的 promise 对象。        此条款允许使用特定实现中的方法来采用符合规范的 promise 对象的状态。        <a href="#ref-3-4" rev="footnote"> ↩</a>    </p><p></p><p id="3-5">    <span style="float: left;">3.5. </span>    </p><p style="margin-left: 32px;">        这个过程首先存储对 <code>x.then</code> 的引用，然后测试该引用，然后调用该引用，        避免了对 <code>x.then</code> 的多次访问。        这一步骤中，我们首先会存储一个指向 x.then 的引用，然后测试该调用，之后调用该引用，        这一系列过程为了防止对 <code>x.then</code> 属性的多处访问。        这些预防措施对于确保访问器属性的一致性非常重要，因为访问器属性的值可能在检索之间发生变化        <sup id="fnref:3">            <a href="#fn:3" rel="footnote">            <span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="ES5 的 getter 特性可能会产生副作用。">                [3]            </span>            </a>        </sup>。        <a href="#ref-3-5" rev="footnote"> ↩</a>    </p><p></p><p id="3-6">    <span style="float: left;">3.6. </span>    </p><p style="margin-left: 32px;">        本规范的实现 <em>不应该</em> 随意限制 thenable 链的深度，并假设在这个限制之外递归是无限的。        只有真正的循环递归才应导致一个 <code>TypeError</code>；如果一条无限长链上的 thenable 对象各不相同，        那么无限递归是正确的行为。        <a href="#ref-3-6" rev="footnote"> ↩</a>    </p><p></p><h1 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">即循环引用。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">即调用时类似[[Resolve]](promise, promise)，这样的话这两个实参是同一个 promise 对象，则会导致无限递归。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">ES5 的 getter 特性可能会产生副作用。<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 规范 </tag>
            
            <tag> 译文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写 Promise</title>
      <link href="/2019/11/28/handwritten-promise/"/>
      <url>/2019/11/28/handwritten-promise/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如果你还没用过 promise，看一看用一用<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的es6</a>。<br>本 Promise 基于 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a> 实现，这里是小弟译的 <a href="http://sunxuedong.com/2019/12/03/translate-promise-a-specifications">Promise/A+规范 translated by 孙雪冬</a>。</p><h3 id="零、promise简介"><a href="#零、promise简介" class="headerlink" title="零、promise简介"></a>零、promise简介</h3><blockquote><ol><li>promise是有状态的。分别为：pending（等待态）、fulfilled（成功态）和rejected（失败态）。</li><li>promise有then方法，并且可以根据 promise 的状态相应的调用回调函数。</li><li>then方法支持链式调用。</li></ol></blockquote><h3 id="一、实现有状态的promise"><a href="#一、实现有状态的promise" class="headerlink" title="一、实现有状态的promise"></a>一、实现有状态的promise</h3><p>1.目标：通过调用resolve或reject来改变promise的状态</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 最终我们可以这样调用</span><span class="token keyword">new</span> <span class="token class-name">Promise2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something...</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Promise2</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>        <span class="token keyword">const</span> resolve <span class="token operator">=</span> value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> reject <span class="token operator">=</span> reason <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、添加then方法"><a href="#二、添加then方法" class="headerlink" title="二、添加then方法"></a>二、添加then方法</h3><p>1.目标：主要思想就是发布与订阅。说白了就是把回调函数存到数组里，等满足一定条件再遍历执行一遍，下面接着上一步👆的代码写。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Promise2</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>        <span class="token comment" spellcheck="true">// 存放 onResolved 回调函数的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 存放 onRejected 回调函数的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">const</span> resolve <span class="token operator">=</span> value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>            <span class="token comment" spellcheck="true">// 等状态变成 fulfilled 后，遍历执行回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> reject <span class="token operator">=</span> reason <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>            <span class="token comment" spellcheck="true">// 等状态变成 rejected 后，遍历执行回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    then <span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">'pending'</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">// 如果当前 promise 状态还是 pending，则将回调函数放在对应的数组里</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token keyword">case</span> <span class="token string">'fulfilled'</span><span class="token punctuation">:</span>                <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token keyword">case</span> <span class="token string">'rejected'</span><span class="token punctuation">:</span>                <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>                <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、then方法的链式调用"><a href="#三、then方法的链式调用" class="headerlink" title="三、then方法的链式调用"></a>三、then方法的链式调用</h3><p>1.目标：使then方法能够链式调用，首先then方法返回的肯定是一个promise对象，如果then方法的回调函数里返回的也是个promise对象，那么最终返回这个promise对象resolve传入的值或then方法里return的值，举几个例子如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// xxx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span>         <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'yyy'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// yyy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，在一顿promise瞎嵌套时，肯定得返回最后一个promise resolve或reject的值。<br>2.实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Promise2</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>        <span class="token comment" spellcheck="true">// 存放 onResolved 回调函数的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 存放 onRejected 回调函数的数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">const</span> resolve <span class="token operator">=</span> value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>            <span class="token comment" spellcheck="true">// 等状态变成 fulfilled 后，遍历执行回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> reject <span class="token operator">=</span> reason <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>            <span class="token comment" spellcheck="true">// 等状态变成 rejected 后，遍历执行回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    then <span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise2</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state            <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">'pending'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">// 如果当前 promise 状态还是 pending，则将回调函数放在对应的数组里</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                      x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>                      <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                      x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>                      <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token keyword">case</span> <span class="token string">'fulfilled'</span><span class="token punctuation">:</span>                    x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>                    <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token keyword">case</span> <span class="token string">'rejected'</span><span class="token punctuation">:</span>                    x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>                    <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>                    <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> promise2    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @func resolvePromise * @desc resolvePromise基于Promise/A+递归处理promise嵌套的函数。 * @desc resolvePromise方法进行递归，如果resolve的值是仍是个promise对象，则递归。 * @desc 直到resolve是个非promise的值才会停止递归。 * @param {object} promise2 - then方法返回的根promise对象 * @param {any} x - then方法回调函数返回的值，分为两类：1.promise对象；2.非promise对象（包括基本数据类型） * @param {function} resolve - 闭包引用，then方法中声明promise2时传入的resolve * @param {function} reject - 闭包引用，then方法中声明promise2时传入的reject */</span><span class="token keyword">function</span> resolvePromise <span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">===</span> promise2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Chaining cycle detected for promise'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> called  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>          called <span class="token operator">=</span> <span class="token boolean">true</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>          called <span class="token operator">=</span> <span class="token boolean">true</span>          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>      called <span class="token operator">=</span> <span class="token boolean">true</span>      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>table表格里应用省略号text-overflow:ellipsis;</title>
      <link href="/2019/11/21/text-overflow-ellipsis-in-table/"/>
      <url>/2019/11/21/text-overflow-ellipsis-in-table/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=115343&auto=1&height=66"></iframe></div><p>本文参考：ccs2.1中文版规范 <a href="http://www.ayqy.net/doc/css2-1/cover.html" target="_blank" rel="noopener">http://www.ayqy.net/doc/css2-1/cover.html</a><br>                  ccs2.1中文版规范table部分 <a href="http://www.ayqy.net/doc/css2-1/tables.html#width-layout" target="_blank" rel="noopener">http://www.ayqy.net/doc/css2-1/tables.html#width-layout</a></p><h3 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h3><p>接到需求，说如果 table 里的字太多就用省略号，很自然就想到 text-overflow:ellipsis (，注意：overflow: hidden; text-overflow:ellipsis; white-space:nowrap 一定要一起用)，但是在 table 中不起作用，问度娘，说要想起作用需给 table元素 设定 table-layout: fixed ，果然起作用了。</p><h3 id="2-text-overflow-ellipsis-起作用的前提"><a href="#2-text-overflow-ellipsis-起作用的前提" class="headerlink" title="2. text-overflow:ellipsis 起作用的前提"></a>2. text-overflow:ellipsis 起作用的前提</h3><blockquote><ol><li>一定要给容器定义宽度<strong>（重点）</strong></li><li>如果少了overflow: hidden;文字会横向撑到容易的外面</li><li>如果少了white-space:nowrap;文字会把容器的高度往下撑；即使你定义了高度，省略号也不会出现，多余的文字会被裁切掉</li><li>如果少了 text-overflow:ellipsis; 多余的文字会被裁切掉，就相当于你这样定义 text-overflow:clip</li></ol></blockquote><h3 id="3-上面重点的前提"><a href="#3-上面重点的前提" class="headerlink" title="3.上面重点的前提"></a>3.上面重点的前提</h3><p><strong>一定要给容器定义宽度</strong>，这就是 table-layout: fixed 起作用，而 table-layout: auto<strong>(table元素默认 auto )</strong> 不起作用的原因，下面一段来自 css2.1 中文版规范：</p><blockquote><p><strong>‘table-layout’</strong><br><em>Value:</em>  auto | fixed | <a href="http://www.ayqy.net/doc/css2-1/cascade.html#value-def-inherit" target="_blank" rel="noopener">inherit</a><br><em>Initial:</em>  auto<br><em>Applies to:</em>  ‘table’和’inline-table’元素<br><em>Inherited:</em>  no<br><em>Percentages:</em>  N/A<br><em>Media:</em>  <a href="http://www.ayqy.net/doc/css2-1/media.html#visual-media-group" target="_blank" rel="noopener">visual</a><br><em>Computed value:</em>  与指定值相同</p></blockquote><blockquote><p><a href="http://www.ayqy.net/doc/css2-1/tables.html#propdef-table-layout" target="_blank" rel="noopener">‘table-layout’</a>属性控制用于表格单元，行和列布局的算法。值含义如下：<br><strong>fixed</strong>: 用固定表格布局算法<br><strong>auto</strong>: 用任意自动表格布局算法</p></blockquote><p><strong>(fixed和auto区别就是一个固定，一个自动)</strong></p><p>下文描述了这两种算法:</p><h5 id="在固定表格布局算法中-fixed-，每列的宽度由下述规则决定："><a href="#在固定表格布局算法中-fixed-，每列的宽度由下述规则决定：" class="headerlink" title="在固定表格布局算法中(fixed)，每列的宽度由下述规则决定："></a>在固定表格布局算法中(fixed)，每列的宽度由下述规则决定：</h5><blockquote><ol><li>一个 width 属性值不为’auto’的列元素所在的列宽度就设置为该宽度值</li><li>否则，由第一行中 width 属性值不为’auto’的单元格确定该列的宽度。如果单元格跨越了多列，就把宽度分到这些列中(the width is divided over the columns)</li><li>所有剩余列均分剩余的水平表格空间 (减去边框或单元格间距)</li></ol></blockquote><p><strong>3中说到，所有剩余列均分剩余的水平表格空间，实际情况就是table将剩余列的宽度平均分，固定每列的宽度就是 剩余宽度/剩余列数 ，text-overflow:ellipsis 起作用的前提就是一定要给容器定义宽度，所以fixed起作用了。</strong></p><h5 id="在自动表格布局算法中-fixed-，列宽由下列步骤决定："><a href="#在自动表格布局算法中-fixed-，列宽由下列步骤决定：" class="headerlink" title="在自动表格布局算法中(fixed)，列宽由下列步骤决定："></a>在自动表格布局算法中(fixed)，列宽由下列步骤决定：</h5><blockquote><ol><li>计算每个单元格的最小内容宽度(MCW)：格式化的内容可以跨越任意多行，但不能从单元格溢出。如果单元格指定的<a href="http://www.ayqy.net/doc/css2-1/visudet.html#propdef-width" target="_blank" rel="noopener">‘width’</a>(W)大于MCW，W就是最小单元格宽度。’auto’值表示MCW是最小单元格宽度，然后，计算每个单元格的“最大”宽度：格式化内容，不考虑除显式换行外的换行</li><li>对于每一列，从只跨越该列的单元格中确定一个最大和最小列宽。最小列宽是最小单元格宽度中最大的那个所需要的最小列宽（或者列<a href="http://www.ayqy.net/doc/css2-1/visudet.html#propdef-width" target="_blank" rel="noopener">‘width’</a>，看哪个更大）。最大列宽是最大单元格宽度中最大的那个所需要的最大列宽（或者列<a href="http://www.ayqy.net/doc/css2-1/visudet.html#propdef-width" target="_blank" rel="noopener">‘width’</a>，看哪个更大）</li><li>对于每个跨越多列的单元格，增加它跨越的列的最小宽度，让它们至少与单元格一样宽。对于最大宽度也这样处理。如果可能的话，把跨越的所有列再扩宽差不多相同宽度</li><li>对于每个’width’不为’auto’的列组元素，增加它跨越的列的最小宽度，让它们至少与列组的’width’一样宽</li></ol></blockquote><p><strong>其实有些事很简单，但是说起来就是绕嘴。。。<br>1中说到，如果单元格指定的<a href="http://www.ayqy.net/doc/css2-1/visudet.html#propdef-width" target="_blank" rel="noopener">‘width’</a>(W)大于MCW，W就是最小单元格宽度。’auto’值表示MCW是最小单元格宽度。</strong></p><p><strong>情况一：当W &gt; MCW时，W是最小单元格宽度，说明 列宽 = W，列宽 装得下文字，用不上省略号。</strong></p><p><strong>情况二：当W &lt; MCW时，MCW是最小单元格宽度时，说明 列宽 = MCW，但是这个MCW是文字撑满下计算出来的，既然是撑满，用省略号干嘛。。。</strong></p><p><strong>要想在不使用table-layout:fixed的情况下，即table-layout:auto前提下用ellipsis，可以像下面这样做(在td里再套一个元素，对这个元素设置ellipsis)</strong></p><pre><code>&lt;style&gt;    div {      width: 100px;    }    .ellipsis {      text-overflow:ellipsis;      overflow: hidden;       text-overflow:ellipsis;       white-space:nowrap;    }&lt;/style&gt;...&lt;td&gt;  &lt;div class=&quot;ellipsis&quot;&gt;    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  &lt;/div&gt;&lt;/td&gt;...</code></pre><p><img src="badge-bg.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
